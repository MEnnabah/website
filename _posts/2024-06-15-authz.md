---
layout: post
title: "The problem with authorisation"
date: 2024-06-15 00:00:00 +0000
categories: abac rbac rebac accesscontrol security
published: false
---

Git repositories are a perfect example to demonstrate the problem.

Let's say we're building a backend service for GitHub. The service receives calls over HTTP, and based on the action, it checks required permissions, and decides whether to accept or reject the call. The word "decide" is key to why I think the current authorisation model is wrong.

To demonstrate the problem, let's assume we have a typical CRUD application, and in no means I pretend I know how GitHub is implemented, the example is mainly to demonstrate the problem with the following endpoints:

- `POST /repository` creates an repository content and returns its ID
- `GET /repository/{ID}` returns a repository file and folder structure
- `GET /repository` returns a list of repositories

Each of these endpoints would have a different authorisation check behind it. Let's take a look at each of them individually.

### `POST /repository`

In a create scenario, an application would create a record, and update the authorisation system to associate the record ID with the user ID. Typically this is done in a 2-phase commit. Here's a diagram of the operations sequence:

{:style="text-align:center;"}
![Create Record](/assets/post240615/create-record.png){: width="220" }

It is up to the application to make sure the data store supports transactions, and the write to the authorisation system is part of the atomic operation. Meaning a failure to write to the authorisation system should rollback the write to the database.

In addition to two-phase commit approach, an architecture could stream writes of its domain database to a message broker, and these events could be consumed to write to the authorisation system. Regardless of the write approach, the problems of authorisation remain the same.

### `GET /repository/{ID}`



### Summary

The drawbacks with this authorisation model are:
1. Each application has to write to both the data store and to the authorisation system, and make sure it does that correctly.
2. Permission check result are up to the interpretation of the application, as we saw in the spaceship example.
3. 